import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { db } from "@/lib/db";
import { generateLivestockTasks, generateCropTasks } from "@/lib/task-generator";

// POST /api/tasks/generate - Generate tasks for existing livestock and crops
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = await request.json();
    const { type, entryId, regenerate } = body;

    let tasksGenerated = 0;
    const results: Array<{ id: string; name: string; tasksGenerated: number }> = [];

    if (type === "livestock" || type === "all") {
      // Get all livestock entries for the user
      const livestockEntries = await db.livestockEntry.findMany({
        where: {
          userId: session.user.id,
          ...(entryId && { id: entryId }),
        },
        include: {
          livestock: true,
        },
      });

      for (const entry of livestockEntries) {
        // Check if tasks already exist for this entry
        const existingTasks = await db.task.count({
          where: {
            relatedType: "livestock",
            relatedId: entry.id,
            isAutoGenerated: true,
          },
        });

        // Skip if tasks already exist and not regenerating
        if (existingTasks > 0 && !regenerate) {
          results.push({
            id: entry.id,
            name: entry.name || entry.livestock.englishName,
            tasksGenerated: 0,
          });
          continue;
        }

        // Delete existing auto-generated tasks if regenerating
        if (regenerate && existingTasks > 0) {
          await db.task.deleteMany({
            where: {
              relatedType: "livestock",
              relatedId: entry.id,
              isAutoGenerated: true,
              status: "PENDING",
            },
          });
        }

        const startDate = entry.acquiredDate || entry.createdAt;
        const count = await generateLivestockTasks({
          userId: session.user.id,
          livestockEntryId: entry.id,
          animalType: entry.livestock.englishName,
          animalName: entry.name || entry.batchId || undefined,
          quantity: entry.quantity,
          startDate,
          generateDaysAhead: 90,
        });

        tasksGenerated += count;
        results.push({
          id: entry.id,
          name: entry.name || entry.livestock.englishName,
          tasksGenerated: count,
        });
      }
    }

    if (type === "crop" || type === "all") {
      // Get all crop entries for the user
      const cropEntries = await db.cropEntry.findMany({
        where: {
          userId: session.user.id,
          ...(entryId && { id: entryId }),
          plantingDate: { not: null }, // Only generate for crops with planting date
        },
        include: {
          crop: true,
        },
      });

      for (const entry of cropEntries) {
        // Check if tasks already exist for this entry
        const existingTasks = await db.task.count({
          where: {
            relatedType: "crop",
            relatedId: entry.id,
            isAutoGenerated: true,
          },
        });

        // Skip if tasks already exist and not regenerating
        if (existingTasks > 0 && !regenerate) {
          results.push({
            id: entry.id,
            name: entry.crop.englishName,
            tasksGenerated: 0,
          });
          continue;
        }

        // Delete existing auto-generated tasks if regenerating
        if (regenerate && existingTasks > 0) {
          await db.task.deleteMany({
            where: {
              relatedType: "crop",
              relatedId: entry.id,
              isAutoGenerated: true,
              status: "PENDING",
            },
          });
        }

        const count = await generateCropTasks({
          userId: session.user.id,
          cropEntryId: entry.id,
          cropName: entry.crop.englishName,
          plotName: entry.plotName || undefined,
          plantingDate: entry.plantingDate!,
          expectedHarvestDate: entry.expectedHarvestDate || undefined,
        });

        tasksGenerated += count;
        results.push({
          id: entry.id,
          name: entry.crop.englishName + (entry.plotName ? ` (${entry.plotName})` : ""),
          tasksGenerated: count,
        });
      }
    }

    return NextResponse.json({
      success: true,
      totalTasksGenerated: tasksGenerated,
      entries: results,
    });
  } catch (error) {
    console.error("Error generating tasks:", error);
    return NextResponse.json(
      { error: "Failed to generate tasks" },
      { status: 500 }
    );
  }
}
