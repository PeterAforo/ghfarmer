// Task Generator - Auto-generates tasks when livestock or crops are added
import { db } from "@/lib/db";
import {
  getCropSchedule,
  getLivestockSchedule,
  CropActivityTemplate,
  LivestockActivityTemplate,
} from "@/lib/activity-schedules";

// ============================================
// LIVESTOCK TASK GENERATION
// ============================================

interface GenerateLivestockTasksParams {
  userId: string;
  livestockEntryId: string;
  animalType: string;
  animalName?: string;
  quantity: number;
  startDate: Date; // Acquisition date
  generateDaysAhead?: number; // How many days ahead to generate tasks (default 90)
}

export async function generateLivestockTasks({
  userId,
  livestockEntryId,
  animalType,
  animalName,
  quantity,
  startDate,
  generateDaysAhead = 90,
}: GenerateLivestockTasksParams): Promise<number> {
  const schedule = getLivestockSchedule(animalType);
  const tasks: Array<{
    userId: string;
    title: string;
    description: string;
    dueDate: Date;
    category: "LIVESTOCK";
    priority: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
    status: "PENDING" | "OVERDUE";
    relatedType: string;
    relatedId: string;
    isAutoGenerated: boolean;
    sourceType: string;
  }> = [];

  const animalLabel = animalName || `${animalType} (${quantity})`;
  const endDate = new Date(startDate.getTime() + generateDaysAhead * 24 * 60 * 60 * 1000);

  for (const activity of schedule) {
    // Calculate first occurrence date
    let taskDate = new Date(startDate.getTime() + activity.daysFromStart * 24 * 60 * 60 * 1000);

    const now = new Date();
    
    // For recurring tasks, generate multiple instances
    if (activity.repeatInterval && activity.repeatInterval > 0) {
      while (taskDate <= endDate) {
        // Determine status based on whether task date is in the past
        const isPastDue = taskDate < now;
        const status = isPastDue ? "OVERDUE" as const : "PENDING" as const;
        
        tasks.push({
          userId,
          title: `${activity.name} - ${animalLabel}`,
          description: `${activity.description}\n\nAnimal: ${animalLabel}\nCategory: ${activity.category}${activity.timeOfDay ? `\nTime: ${activity.timeOfDay}` : ""}${isPastDue ? "\n\n⚠️ This task was auto-generated for a past date. Please review and update status." : ""}`,
          dueDate: taskDate,
          category: "LIVESTOCK",
          priority: activity.priority,
          status,
          relatedType: "livestock",
          relatedId: livestockEntryId,
          isAutoGenerated: true,
          sourceType: activity.category.toLowerCase(),
        });
        // Move to next occurrence
        taskDate = new Date(taskDate.getTime() + activity.repeatInterval * 24 * 60 * 60 * 1000);
      }
    } else {
      // One-time task - create if within range (past or future)
      if (taskDate <= endDate) {
        const isPastDue = taskDate < now;
        const status = isPastDue ? "OVERDUE" as const : "PENDING" as const;
        
        tasks.push({
          userId,
          title: `${activity.name} - ${animalLabel}`,
          description: `${activity.description}\n\nAnimal: ${animalLabel}\nCategory: ${activity.category}${isPastDue ? "\n\n⚠️ This task was auto-generated for a past date. Please review and update status." : ""}`,
          dueDate: taskDate,
          category: "LIVESTOCK",
          priority: activity.priority,
          status,
          relatedType: "livestock",
          relatedId: livestockEntryId,
          isAutoGenerated: true,
          sourceType: activity.category.toLowerCase(),
        });
      }
    }
  }

  // Batch create tasks
  if (tasks.length > 0) {
    await db.task.createMany({
      data: tasks,
    });
  }

  return tasks.length;
}

// ============================================
// CROP TASK GENERATION
// ============================================

interface GenerateCropTasksParams {
  userId: string;
  cropEntryId: string;
  cropName: string;
  plotName?: string;
  plantingDate: Date;
  expectedHarvestDate?: Date;
}

export async function generateCropTasks({
  userId,
  cropEntryId,
  cropName,
  plotName,
  plantingDate,
  expectedHarvestDate,
}: GenerateCropTasksParams): Promise<number> {
  const schedule = getCropSchedule(cropName);
  const tasks: Array<{
    userId: string;
    title: string;
    description: string;
    dueDate: Date;
    category: "CROP";
    priority: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
    status: "PENDING" | "OVERDUE";
    relatedType: string;
    relatedId: string;
    isAutoGenerated: boolean;
    sourceType: string;
  }> = [];

  const cropLabel = plotName ? `${cropName} (${plotName})` : cropName;
  const now = new Date();

  for (const activity of schedule) {
    // Calculate task date from planting date
    const taskDate = new Date(plantingDate.getTime() + activity.daysFromPlanting * 24 * 60 * 60 * 1000);

    // Determine status based on whether task date is in the past
    const isPastDue = taskDate < now;
    const status = isPastDue ? "OVERDUE" as const : "PENDING" as const;

    // Create tasks for all dates (past and future) so user can review and update
    tasks.push({
      userId,
      title: `${activity.name} - ${cropLabel}`,
      description: `${activity.description}\n\nCrop: ${cropLabel}\nCategory: ${activity.category}${activity.durationDays ? `\nDuration: ${activity.durationDays} days` : ""}${isPastDue ? "\n\n⚠️ This task was auto-generated for a past date. Please review and update status." : ""}`,
      dueDate: taskDate,
      category: "CROP",
      priority: activity.priority,
      status,
      relatedType: "crop",
      relatedId: cropEntryId,
      isAutoGenerated: true,
      sourceType: activity.category.toLowerCase(),
    });
  }

  // Batch create tasks
  if (tasks.length > 0) {
    await db.task.createMany({
      data: tasks,
    });
  }

  return tasks.length;
}

// ============================================
// TASK MANAGEMENT UTILITIES
// ============================================

// Mark a task as completed
export async function completeTask(taskId: string, userId: string): Promise<boolean> {
  const task = await db.task.findFirst({
    where: { id: taskId, userId },
  });

  if (!task) {
    return false;
  }

  await db.task.update({
    where: { id: taskId },
    data: {
      status: "COMPLETED",
      completedAt: new Date(),
    },
  });

  return true;
}

// Get upcoming tasks for a user
export async function getUpcomingTasks(
  userId: string,
  daysAhead: number = 7,
  category?: "CROP" | "LIVESTOCK" | "AQUACULTURE" | "FINANCIAL" | "GENERAL"
) {
  const endDate = new Date(Date.now() + daysAhead * 24 * 60 * 60 * 1000);

  return db.task.findMany({
    where: {
      userId,
      status: { in: ["PENDING", "IN_PROGRESS"] },
      dueDate: { lte: endDate },
      ...(category && { category }),
    },
    orderBy: [
      { dueDate: "asc" },
      { priority: "desc" },
    ],
  });
}

// Get overdue tasks
export async function getOverdueTasks(
  userId: string,
  category?: "CROP" | "LIVESTOCK" | "AQUACULTURE" | "FINANCIAL" | "GENERAL"
) {
  return db.task.findMany({
    where: {
      userId,
      status: { in: ["PENDING", "IN_PROGRESS"] },
      dueDate: { lt: new Date() },
      ...(category && { category }),
    },
    orderBy: [
      { priority: "desc" },
      { dueDate: "asc" },
    ],
  });
}

// Get tasks for a specific livestock entry
export async function getLivestockTasks(userId: string, livestockEntryId: string) {
  return db.task.findMany({
    where: {
      userId,
      relatedType: "livestock",
      relatedId: livestockEntryId,
    },
    orderBy: { dueDate: "asc" },
  });
}

// Get tasks for a specific crop entry
export async function getCropTasks(userId: string, cropEntryId: string) {
  return db.task.findMany({
    where: {
      userId,
      relatedType: "crop",
      relatedId: cropEntryId,
    },
    orderBy: { dueDate: "asc" },
  });
}

// Delete all auto-generated tasks for a livestock entry (when entry is deleted)
export async function deleteLivestockTasks(livestockEntryId: string) {
  return db.task.deleteMany({
    where: {
      relatedType: "livestock",
      relatedId: livestockEntryId,
      isAutoGenerated: true,
    },
  });
}

// Delete all auto-generated tasks for a crop entry (when entry is deleted)
export async function deleteCropTasks(cropEntryId: string) {
  return db.task.deleteMany({
    where: {
      relatedType: "crop",
      relatedId: cropEntryId,
      isAutoGenerated: true,
    },
  });
}

// Regenerate tasks for livestock (e.g., extend schedule)
export async function regenerateLivestockTasks(
  userId: string,
  livestockEntryId: string,
  animalType: string,
  animalName: string | undefined,
  quantity: number,
  startDate: Date,
  generateDaysAhead: number = 90
) {
  // Delete existing auto-generated tasks that are still pending
  await db.task.deleteMany({
    where: {
      relatedType: "livestock",
      relatedId: livestockEntryId,
      isAutoGenerated: true,
      status: "PENDING",
    },
  });

  // Generate new tasks
  return generateLivestockTasks({
    userId,
    livestockEntryId,
    animalType,
    animalName,
    quantity,
    startDate,
    generateDaysAhead,
  });
}
