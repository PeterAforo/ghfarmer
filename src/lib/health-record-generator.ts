import { db } from "@/lib/db";
import { getHealthSchedule, HealthRecordTemplate } from "./health-record-templates";

interface GenerateHealthRecordsParams {
  livestockEntryId: string;
  animalType: string;
  startDate: Date;
  generateDaysAhead?: number; // How many days ahead to generate records
}

/**
 * Generate health records (vaccinations, deworming) for a livestock entry
 * based on the animal type's health schedule
 */
export async function generateHealthRecords({
  livestockEntryId,
  animalType,
  startDate,
  generateDaysAhead = 730, // Default to 2 years for full lifespan coverage
}: GenerateHealthRecordsParams): Promise<number> {
  const schedule = getHealthSchedule(animalType);
  
  if (!schedule || schedule.length === 0) {
    console.log(`No health schedule found for animal type: ${animalType}`);
    return 0;
  }

  console.log(`Generating health records for ${animalType} with ${schedule.length} templates`);

  const healthRecords: {
    livestockEntryId: string;
    type: "VACCINATION" | "DEWORMING";
    status: "PENDING" | "OVERDUE";
    date: Date;
    vaccineName: string | null;
    nextDueDate: Date | null;
    notes: string | null;
    isAutoGenerated: boolean;
  }[] = [];

  const cutoffDate = new Date(startDate);
  cutoffDate.setDate(cutoffDate.getDate() + generateDaysAhead);
  const now = new Date();

  for (const template of schedule) {
    // Calculate initial date
    const initialDate = new Date(startDate);
    initialDate.setDate(initialDate.getDate() + template.daysFromAcquisition);

    // Skip if initial date is beyond cutoff
    if (initialDate > cutoffDate) {
      continue;
    }

    // Determine status based on whether date is in the past
    const isPastDue = initialDate < now;
    const status = isPastDue ? "OVERDUE" as const : "PENDING" as const;

    // Create the initial record
    const nextDueDate = template.repeatIntervalDays
      ? new Date(initialDate.getTime() + template.repeatIntervalDays * 24 * 60 * 60 * 1000)
      : null;

    healthRecords.push({
      livestockEntryId,
      type: template.type,
      status,
      date: initialDate,
      vaccineName: template.type === "VACCINATION" ? template.name : null,
      nextDueDate,
      notes: buildNotes(template, false, isPastDue),
      isAutoGenerated: true,
    });

    // Generate recurring records if applicable
    if (template.repeatIntervalDays) {
      let currentDate = new Date(initialDate);
      currentDate.setDate(currentDate.getDate() + template.repeatIntervalDays);

      // Generate recurring instances until cutoff date (covers full lifespan)
      // No artificial limit - generate all needed records for the timeframe
      while (currentDate <= cutoffDate) {
        const nextDue = new Date(currentDate);
        nextDue.setDate(nextDue.getDate() + template.repeatIntervalDays);

        const isRecurringPastDue = currentDate < now;
        const recurringStatus = isRecurringPastDue ? "OVERDUE" as const : "PENDING" as const;

        healthRecords.push({
          livestockEntryId,
          type: template.type,
          status: recurringStatus,
          date: new Date(currentDate),
          vaccineName: template.type === "VACCINATION" ? template.name : null,
          nextDueDate: nextDue <= cutoffDate ? nextDue : null,
          notes: buildNotes(template, true, isRecurringPastDue),
          isAutoGenerated: true,
        });

        currentDate = new Date(currentDate);
        currentDate.setDate(currentDate.getDate() + template.repeatIntervalDays);
      }
    }
  }

  // Check for existing health records to avoid duplicates
  const existingRecords = await db.healthRecord.findMany({
    where: { livestockEntryId },
    select: { type: true, date: true, vaccineName: true },
  });

  // Filter out duplicates
  const newRecords = healthRecords.filter((record) => {
    return !existingRecords.some(
      (existing) =>
        existing.type === record.type &&
        existing.vaccineName === record.vaccineName &&
        existing.date.toDateString() === record.date.toDateString()
    );
  });

  if (newRecords.length === 0) {
    return 0;
  }

  // Create health records in database
  const result = await db.healthRecord.createMany({
    data: newRecords,
  });

  return result.count;
}

/**
 * Build notes string from template
 */
function buildNotes(template: HealthRecordTemplate, isRecurring = false, isPastDue = false): string {
  const parts: string[] = [];

  if (template.description) {
    parts.push(template.description);
  }

  if (template.dosageInfo) {
    parts.push(`Dosage: ${template.dosageInfo}`);
  }

  if (template.notes) {
    parts.push(template.notes);
  }

  if (isRecurring) {
    parts.push("(Recurring scheduled treatment)");
  }

  parts.push(`Priority: ${template.priority}`);

  if (isPastDue) {
    parts.push("⚠️ This record was auto-generated for a past date. Please review and update status.");
  }

  return parts.join(" | ");
}

/**
 * Generate health records for all livestock entries that don't have any
 */
export async function generateHealthRecordsForAllLivestock(
  userId: string
): Promise<{ entriesProcessed: number; recordsGenerated: number }> {
  const entries = await db.livestockEntry.findMany({
    where: {
      userId,
      status: { notIn: ["SOLD", "DECEASED"] },
    },
    include: {
      livestock: { select: { englishName: true } },
      _count: { select: { healthRecords: true } },
    },
  });

  let totalRecords = 0;
  let entriesProcessed = 0;

  for (const entry of entries) {
    // Only generate for entries with no health records
    if (entry._count.healthRecords === 0) {
      const startDate = entry.acquiredDate || entry.createdAt;
      const recordsGenerated = await generateHealthRecords({
        livestockEntryId: entry.id,
        animalType: entry.livestock?.englishName || "Unknown",
        startDate,
      });

      if (recordsGenerated > 0) {
        totalRecords += recordsGenerated;
        entriesProcessed++;
      }
    }
  }

  return { entriesProcessed, recordsGenerated: totalRecords };
}
