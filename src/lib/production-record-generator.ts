import { db } from "@/lib/db";
import { getProductionSchedule, ProductionMilestone } from "./production-record-templates";
import { DEFAULT_UNIT_PRICES } from "@/app/api/user/settings/route";

interface GenerateProductionRecordsParams {
  livestockEntryId: string;
  animalType: string;
  quantity: number;
  startDate: Date;
  generateDaysAhead?: number;
  userId?: string; // To fetch user's custom prices
  expectedSellingPrice?: number; // User-defined selling price from livestock entry
}

/**
 * Get user's custom unit prices or fall back to defaults
 */
async function getUserPrices(userId?: string): Promise<Record<string, number>> {
  if (!userId) return DEFAULT_UNIT_PRICES;
  
  try {
    const user = await db.user.findUnique({
      where: { id: userId },
      select: { unitPrices: true },
    });
    
    return {
      ...DEFAULT_UNIT_PRICES,
      ...(user?.unitPrices as Record<string, number> || {}),
    };
  } catch {
    return DEFAULT_UNIT_PRICES;
  }
}

/**
 * Get the appropriate price key for an animal type
 */
function getPriceKey(animalType: string, productionType: string): string {
  const typeMap: Record<string, Record<string, string>> = {
    "Layer": { EGGS: "eggs", WEIGHT: "chickenMeat" },
    "Chicken": { EGGS: "eggs", WEIGHT: "chickenMeat" },
    "Broiler": { WEIGHT: "broilerMeat" },
    "Turkey": { WEIGHT: "turkeyMeat" },
    "Duck": { EGGS: "eggs", WEIGHT: "duckMeat" },
    "Guinea Fowl": { EGGS: "eggs", WEIGHT: "guineaFowlMeat" },
    "Cattle": { MILK: "cowMilk", WEIGHT: "cattleMeat" },
    "Goat": { MILK: "goatMilk", WEIGHT: "goatMeat" },
    "Sheep": { MILK: "goatMilk", WEIGHT: "sheepMeat" },
    "Pig": { WEIGHT: "pigMeat" },
    "Rabbit": { WEIGHT: "rabbitMeat" },
  };
  
  const normalizedType = Object.keys(typeMap).find(
    key => animalType.toLowerCase().includes(key.toLowerCase())
  );
  
  if (normalizedType && typeMap[normalizedType][productionType]) {
    return typeMap[normalizedType][productionType];
  }
  
  // Default fallbacks
  if (productionType === "EGGS") return "eggs";
  if (productionType === "MILK") return "cowMilk";
  return "chickenMeat";
}

/**
 * Generate expected production milestone records for a livestock entry
 */
export async function generateProductionRecords({
  livestockEntryId,
  animalType,
  quantity,
  startDate,
  generateDaysAhead = 365,
  userId,
  expectedSellingPrice,
}: GenerateProductionRecordsParams): Promise<number> {
  const schedule = getProductionSchedule(animalType);

  if (!schedule || schedule.length === 0) {
    console.log(`No production schedule found for animal type: ${animalType}`);
    return 0;
  }

  // Get user's custom prices (livestock entry price takes priority)
  const userPrices = await getUserPrices(userId);
  
  // If user provided expectedSellingPrice on the livestock entry, use that as override
  const entrySellingPrice = expectedSellingPrice;

  const productionRecords: {
    livestockEntryId: string;
    date: Date;
    type: "EGGS" | "MILK" | "WEIGHT" | "OTHER";
    status: "EXPECTED";
    expectedEggCount: number | null;
    expectedMilkVolume: number | null;
    expectedWeight: number | null;
    expectedRevenue: number | null;
    unitPrice: number | null;
    eggCount: number | null;
    milkVolume: number | null;
    milkUnit: string | null;
    weight: number | null;
    weightUnit: string | null;
    notes: string | null;
    isAutoGenerated: boolean;
  }[] = [];

  const cutoffDate = new Date(startDate);
  cutoffDate.setDate(cutoffDate.getDate() + generateDaysAhead);

  for (const milestone of schedule) {
    const milestoneDate = new Date(startDate);
    milestoneDate.setDate(milestoneDate.getDate() + milestone.daysFromAcquisition);

    // Skip if milestone date is beyond cutoff
    if (milestoneDate > cutoffDate) {
      continue;
    }

    // Get the appropriate unit price - entry selling price takes priority
    const priceKey = getPriceKey(animalType, milestone.type);
    const unitPrice = entrySellingPrice || userPrices[priceKey] || milestone.expectedRevenuePerUnit || 0;

    // Build the record based on production type
    const record: {
      livestockEntryId: string;
      date: Date;
      type: "EGGS" | "MILK" | "WEIGHT" | "OTHER";
      status: "EXPECTED";
      expectedEggCount: number | null;
      expectedMilkVolume: number | null;
      expectedWeight: number | null;
      expectedRevenue: number | null;
      unitPrice: number | null;
      eggCount: number | null;
      milkVolume: number | null;
      milkUnit: string | null;
      weight: number | null;
      weightUnit: string | null;
      notes: string | null;
      isAutoGenerated: boolean;
    } = {
      livestockEntryId,
      date: milestoneDate,
      type: milestone.type,
      status: "EXPECTED",
      expectedEggCount: null,
      expectedMilkVolume: null,
      expectedWeight: null,
      expectedRevenue: null,
      unitPrice,
      eggCount: null,
      milkVolume: null,
      milkUnit: null,
      weight: null,
      weightUnit: null,
      notes: buildProductionNotes(milestone, quantity, unitPrice),
      isAutoGenerated: true,
    };

    // Set type-specific fields with expected values
    switch (milestone.type) {
      case "EGGS":
        // Expected eggs = daily production * quantity
        record.expectedEggCount = Math.round((milestone.expectedDailyProduction || 0) * quantity);
        record.expectedRevenue = record.expectedEggCount * unitPrice;
        break;
      case "MILK":
        record.expectedMilkVolume = (milestone.expectedDailyProduction || 0) * quantity;
        record.milkUnit = "liters";
        record.expectedRevenue = record.expectedMilkVolume * unitPrice;
        break;
      case "WEIGHT":
        record.expectedWeight = milestone.expectedDailyProduction || 0;
        record.weightUnit = "kg";
        // For weight, revenue is total weight * quantity * price
        record.expectedRevenue = record.expectedWeight * quantity * unitPrice;
        break;
    }

    productionRecords.push(record);
  }

  // Check for existing production records to avoid duplicates
  const existingRecords = await db.productionRecord.findMany({
    where: { livestockEntryId },
    select: { type: true, date: true },
  });

  // Filter out duplicates (same type and date)
  const newRecords = productionRecords.filter((record) => {
    return !existingRecords.some(
      (existing) =>
        existing.type === record.type &&
        existing.date.toDateString() === record.date.toDateString()
    );
  });

  if (newRecords.length === 0) {
    return 0;
  }

  // Create production records in database
  const result = await db.productionRecord.createMany({
    data: newRecords,
  });

  return result.count;
}

/**
 * Build notes string from milestone
 */
function buildProductionNotes(milestone: ProductionMilestone, quantity: number, unitPrice?: number): string {
  const parts: string[] = [];

  parts.push(`ðŸ“Š ${milestone.name}`);
  parts.push(milestone.description);

  if (milestone.expectedDailyProduction) {
    const totalExpected = milestone.expectedDailyProduction * quantity;
    parts.push(`Expected: ${totalExpected.toFixed(1)} ${milestone.productionUnit || "units"} (${quantity} animals Ã— ${milestone.expectedDailyProduction} each)`);
  }

  const priceToUse = unitPrice || milestone.expectedRevenuePerUnit;
  if (priceToUse && milestone.expectedDailyProduction) {
    const dailyRevenue = milestone.expectedDailyProduction * quantity * priceToUse;
    parts.push(`Expected revenue: GHS ${dailyRevenue.toFixed(2)} @ GHS ${priceToUse}/unit`);
  }

  if (milestone.durationDays) {
    parts.push(`Duration: ${milestone.durationDays} days`);
  }

  if (milestone.notes) {
    parts.push(`Note: ${milestone.notes}`);
  }

  return parts.join(" | ");
}

/**
 * Generate production records for all livestock entries that don't have any
 */
export async function generateProductionRecordsForAllLivestock(
  userId: string
): Promise<{ entriesProcessed: number; recordsGenerated: number }> {
  const entries = await db.livestockEntry.findMany({
    where: {
      userId,
      status: { notIn: ["SOLD", "DECEASED"] },
    },
    include: {
      livestock: { select: { englishName: true } },
      _count: { select: { productionRecords: true } },
    },
  });

  let totalRecords = 0;
  let entriesProcessed = 0;

  for (const entry of entries) {
    // Only generate for entries with no production records
    if (entry._count.productionRecords === 0) {
      const startDate = entry.acquiredDate || entry.createdAt;
      const recordsGenerated = await generateProductionRecords({
        livestockEntryId: entry.id,
        animalType: entry.livestock?.englishName || "Unknown",
        quantity: entry.quantity,
        startDate,
      });

      if (recordsGenerated > 0) {
        totalRecords += recordsGenerated;
        entriesProcessed++;
      }
    }
  }

  return { entriesProcessed, recordsGenerated: totalRecords };
}
